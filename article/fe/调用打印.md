# 方法一：使用第三方组件

# 方法二：调用原生打印

## 采用截取部分文字打印

尝试了很多种方法，打印功能都可以实现，但是大多数原生浏览器打印多为打印`body`无法对其控制和选择

尝试打印了部分内容，但是因为我的内容是一个`Dialog`是个弹窗，只是效果更像页面，模拟打印时，虽然是白底黑字的表格，但实际上仍存储了整个页面的全部内容

如图

![深度截图_选择区域_20190124165745](/uploads/5e91ccf94e7cee92d42111948fad032b/深度截图_选择区域_20190124165745.png)

1. 截取所需网页内容

建立两个`<a>`标签，注明所需打印的开头和结尾（原生html可以采用`<!--start-->`注释方法貌似效果更好）

当然，他是隐藏的`display:none`

`MixTable`即需要打印的内容

```javascript

 <div>
          <a className={Style.Print}>startprint</a>
          <MixTable noticeData={tableData} />
          <a className={Style.Print}>endprint</a>
</div>
```

2. 执行打印方法
```javascript

 private printInfo(data: any, e: React.ChangeEvent<HTMLSelectElement>) {
    // 获取图表数据
    // console.log(data);
    var href = window.location.href;

    console.log(href);

    try {
      //执行打印检查
      this.checkPrint()
      //截取所需打印的内容
      let bdhtml = window.document.body.innerHTML;
      const sprnstr = "startprint";
      const eprnstr = "endprint";
      let prnhtml = bdhtml.substr(bdhtml.indexOf(sprnstr) + 10);
      prnhtml = prnhtml.substring(0, prnhtml.indexOf(eprnstr));
      window.document.body.innerHTML = prnhtml;
      //执行打印
      window.print();
      //执行打印后再做一次检查
      this.checkPrint()
    } catch (error) {
      console.log(error);
    }

  }

  //检查打印功能
  private checkPrint() {
    const beforePrint = () => {
      console.log('Functionality to run before printing.');
    };

    const afterPrint = () => {
      
      //兼容Firefox方案：
      console.log('Functionality to run after printing');
      let url = window.location.href;
      let parm = parseInt((Math.random() * 10).toString())
      if (url.lastIndexOf('?') > -1) {
        url = url + parm;
      } else {
        url = url + "?" + parm;
      }
      window.location.href = url;
    };

    if (window.matchMedia) {
      let mediaQueryList = window.matchMedia('print');
      mediaQueryList.addListener(function (mql) {
        if (mql.matches) {
          beforePrint();
        } else {
          afterPrint();
        }
      });
    }

    window.onbeforeprint = beforePrint;
    window.onafterprint = afterPrint;
  }

  ```
  但是效果并不理想

## 新页面打印

最后选择了一个比较粗暴的方法以解燃眉之急

1. 将截取内容丢到新的页面
2. 打开新页面，直接进行页面打印，打印新页面的全部（`body`)


### 操作方法：


1. 在打印按钮中调用如下方法

```javascript
//执行打印
  //目前采用的方法：iframe打开新窗口，并且打印新窗口body部分
  private printInfo(data: any, e: React.ChangeEvent<HTMLSelectElement>) {
    try {
      //为避免火狐等兼容性问题，多给一个flag参数，防止数据不刷新
      const flag = parseInt((Math.random() * 100).toString())
      const printId = e.currentTarget.getAttribute('data-id')
      const state = e.currentTarget.getAttribute('data-state')
      this.printIframe.push(
        <iframe src={`http://builder.duobang.test/org/i/${this.props.orgId}/mixingstation/print?${printId}?${flag}`} />
      )
      this.setState({})
      //执行打印页面后重新生成一次，但不用setState.
      this.creatTable(parseInt(printId), state, data)
    } catch (error) {
      console.log(error);
    }

  }
```

为弹窗push一个`iframe` ，这个`iframe`页面内容，即我们要打印的全部内容

`iframe`的`src`为  =》`http://builder.duobang.test/org/i/${this.props.orgId}/mixingstation/print?${printId}?${flag}`

这是一个新建立的路由跳转，共有三个参数，一个是`orgId`,一个是`printId`,最后一个是`flag`

```json
orgId:当前组织Id 
printId:所需要打印的`noticeID`
flag:一个随机数，避免火狐等浏览器因缓存机制，造成iframe页面不刷新
```

2. 将截取内容丢到新的页面

```javascript
public componentWillMount() {
    //获取网址参数，对相关内容解析
    const href = window.location.href;
    //解析？隔开的三个参数
    const noticeId = href.split('?')[1]
    //赋予其执行打印的条件
    if (noticeId !== 'undefined' && this.noticeFlag !== parseInt(href.split('?')[2])) {
      this.noticeId = parseInt(noticeId)
      this.getNoticeInfo(parseInt(noticeId))
      this.noticeFlag = parseInt(href.split('?')[2])

      this.setState({})
    }
  }
```

本次将打印放在了`this.getNoticeInfo()`中，在获取到数据渲染完成后直接打印


